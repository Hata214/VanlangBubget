/**
 * üó£Ô∏è Enhanced Conversation Handler for VanLang Agent
 * Handles complex conversations with context awareness and personalization
 */

import ConversationManager from './conversationManager.js';
import logger from '../utils/logger.js';

class EnhancedConversationHandler {
    constructor(vanlangAgent) {
        this.agent = vanlangAgent;
        this.conversationManager = new ConversationManager();
        
        // Conversation patterns for different scenarios
        this.conversationPatterns = {
            greeting_with_question: /^(ch√†o|hello|hi).*(l√†m th·∫ø n√†o|how|c√°ch|gi√∫p)/i,
            follow_up_question: /^(c√≤n|v√†|th√™m|n·ªØa|kh√°c).*(g√¨|what|how)/i,
            clarification_request: /^(√Ω b·∫°n l√†|you mean|t·ª©c l√†|nghƒ©a l√†)/i,
            comparison_request: /^(so s√°nh|compare|kh√°c nhau|difference)/i,
            step_by_step_request: /^(t·ª´ng b∆∞·ªõc|step by step|h∆∞·ªõng d·∫´n|guide)/i
        };

        // Start cleanup interval (every 10 minutes)
        setInterval(() => {
            this.conversationManager.cleanupExpiredConversations();
        }, 10 * 60 * 1000);
    }

    /**
     * üéØ Main conversation handler
     */
    async handleConversation(userId, message, financialData = null) {
        try {
            // Add user message to conversation history
            this.conversationManager.addMessage(userId, message, 'user');

            // Get conversation context
            const context = this.conversationManager.getConversationContext(userId);

            // Check if user is in a conversation flow
            if (context.currentFlow) {
                return await this.handleFlowConversation(userId, message, context);
            }

            // Analyze conversation intent
            const intentAnalysis = this.conversationManager.analyzeConversationIntent(message);

            // Check for conversation patterns
            const patternMatch = this.detectConversationPattern(message);

            // Generate personalized response
            const response = await this.generatePersonalizedResponse(
                userId, 
                message, 
                intentAnalysis, 
                patternMatch, 
                financialData
            );

            // Add agent response to conversation history
            this.conversationManager.addMessage(userId, response, 'agent');

            // Generate follow-up questions
            const followUps = this.conversationManager.generateFollowUpQuestions(userId, message);

            return {
                response,
                followUpQuestions: followUps,
                conversationContext: {
                    sessionId: context.sessionId,
                    messageCount: context.messages.length,
                    suggestedFlow: intentAnalysis.suggestedFlow,
                    patternDetected: patternMatch
                }
            };

        } catch (error) {
            logger.error('Error in enhanced conversation handler:', error);
            return {
                response: 'Xin l·ªói, t√¥i g·∫∑p l·ªói khi x·ª≠ l√Ω cu·ªôc h·ªôi tho·∫°i. B·∫°n c√≥ th·ªÉ th·ª≠ h·ªèi l·∫°i kh√¥ng?',
                followUpQuestions: [],
                conversationContext: null
            };
        }
    }

    /**
     * üîÑ Handle conversation flow
     */
    async handleFlowConversation(userId, message, context) {
        const flowResult = this.conversationManager.advanceConversationFlow(userId, message);

        if (!flowResult) {
            return {
                response: 'C√≥ l·ªói trong qu√° tr√¨nh h·ªôi tho·∫°i. H√£y b·∫Øt ƒë·∫ßu l·∫°i nh√©!',
                followUpQuestions: []
            };
        }

        if (flowResult.isComplete) {
            // Generate final recommendation based on collected data
            const recommendation = await this.generateFlowRecommendation(
                userId, 
                flowResult.flowType, 
                flowResult.collectedData
            );

            return {
                response: recommendation,
                followUpQuestions: [
                    "B·∫°n c√≥ mu·ªën t√¥i gi·∫£i th√≠ch chi ti·∫øt h∆°n kh√¥ng?",
                    "B·∫°n c√≥ c√¢u h·ªèi n√†o kh√°c v·ªÅ k·∫ø ho·∫°ch n√†y kh√¥ng?",
                    "B·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu th·ª±c hi·ªán ngay kh√¥ng?"
                ],
                conversationContext: {
                    flowCompleted: true,
                    flowType: flowResult.flowType
                }
            };
        } else {
            return {
                response: `üìã **B∆∞·ªõc ${flowResult.progress + 1}/${flowResult.totalSteps}:** ${flowResult.prompt}`,
                followUpQuestions: [],
                conversationContext: {
                    currentFlow: flowResult.flowType,
                    currentStep: flowResult.currentStep,
                    progress: flowResult.progress
                }
            };
        }
    }

    /**
     * üîç Detect conversation patterns
     */
    detectConversationPattern(message) {
        for (const [pattern, regex] of Object.entries(this.conversationPatterns)) {
            if (regex.test(message)) {
                return pattern;
            }
        }
        return null;
    }

    /**
     * üé® Generate personalized response
     */
    async generatePersonalizedResponse(userId, message, intentAnalysis, patternMatch, financialData) {
        // Get user's financial context
        const userFinancialData = financialData || await this.agent.getUserFinancialData(userId);

        // Build personalized prompt
        const personalizedPrompt = this.buildPersonalizedPrompt(
            message, 
            userFinancialData, 
            intentAnalysis, 
            patternMatch
        );

        // Get conversation context for better responses
        const context = this.conversationManager.getConversationContext(userId);
        const recentMessages = context.messages.slice(-3).map(m => `${m.type}: ${m.content}`).join('\n');

        const enhancedPrompt = `
${personalizedPrompt}

**Ng·ªØ c·∫£nh cu·ªôc h·ªôi tho·∫°i g·∫ßn ƒë√¢y:**
${recentMessages}

**H∆∞·ªõng d·∫´n ph·∫£n h·ªìi:**
- S·ª≠ d·ª•ng th√¥ng tin t√†i ch√≠nh c√° nh√¢n ƒë·ªÉ ƒë∆∞a ra l·ªùi khuy√™n c·ª• th·ªÉ
- Tham kh·∫£o c√°c tin nh·∫Øn tr∆∞·ªõc ƒë√≥ ƒë·ªÉ duy tr√¨ t√≠nh li√™n t·ª•c
- ƒê·ªÅ xu·∫•t h√†nh ƒë·ªông c·ª• th·ªÉ d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø
- S·ª≠ d·ª•ng emoji ph√π h·ª£p ƒë·ªÉ l√†m r√µ n·ªôi dung
- Gi·ªØ tone th√¢n thi·ªán v√† chuy√™n nghi·ªáp

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, t·ªëi ƒëa 200 t·ª´.`;

        try {
            const response = await this.agent.callGeminiAI(enhancedPrompt, { 
                temperature: 0.7,
                maxOutputTokens: 512
            });

            // Check if should suggest conversation flow
            if (intentAnalysis.suggestedFlow && intentAnalysis.confidence > 0.7) {
                const flowSuggestion = this.generateFlowSuggestion(intentAnalysis.suggestedFlow);
                return `${response}\n\n${flowSuggestion}`;
            }

            return response;

        } catch (error) {
            logger.error('Error generating personalized response:', error);
            return this.getFallbackResponse(message, userFinancialData);
        }
    }

    /**
     * üèóÔ∏è Build personalized prompt
     */
    buildPersonalizedPrompt(message, financialData, intentAnalysis, patternMatch) {
        const summary = financialData.summary || {};
        
        let prompt = `
B·∫°n l√† VanLang Agent - tr·ª£ l√Ω t√†i ch√≠nh AI th√¥ng minh. H√£y tr·∫£ l·ªùi c√¢u h·ªèi sau m·ªôt c√°ch c√° nh√¢n h√≥a: "${message}"

**Th√¥ng tin t√†i ch√≠nh c·ªßa ng∆∞·ªùi d√πng:**
- T·ªïng thu nh·∫≠p: ${(summary.totalIncomes || 0).toLocaleString('vi-VN')} VND
- T·ªïng chi ti√™u: ${(summary.totalExpenses || 0).toLocaleString('vi-VN')} VND
- S·ªë d∆∞: ${((summary.totalIncomes || 0) - (summary.totalExpenses || 0)).toLocaleString('vi-VN')} VND
- T·ªïng ƒë·∫ßu t∆∞: ${(summary.totalInvestments || 0).toLocaleString('vi-VN')} VND
- T·ªïng kho·∫£n vay: ${(summary.totalLoans || 0).toLocaleString('vi-VN')} VND`;

        // Add pattern-specific context
        if (patternMatch) {
            switch (patternMatch) {
                case 'greeting_with_question':
                    prompt += '\n\n**L∆∞u √Ω:** ƒê√¢y l√† l·ªùi ch√†o k·∫øt h·ª£p v·ªõi c√¢u h·ªèi. H√£y ch√†o l·∫°i v√† tr·∫£ l·ªùi c√¢u h·ªèi.';
                    break;
                case 'follow_up_question':
                    prompt += '\n\n**L∆∞u √Ω:** ƒê√¢y l√† c√¢u h·ªèi ti·∫øp theo. H√£y m·ªü r·ªông th√¥ng tin d·ª±a tr√™n ng·ªØ c·∫£nh.';
                    break;
                case 'comparison_request':
                    prompt += '\n\n**L∆∞u √Ω:** Ng∆∞·ªùi d√πng mu·ªën so s√°nh. H√£y ƒë∆∞a ra b·∫£ng so s√°nh r√µ r√†ng.';
                    break;
                case 'step_by_step_request':
                    prompt += '\n\n**L∆∞u √Ω:** Ng∆∞·ªùi d√πng mu·ªën h∆∞·ªõng d·∫´n t·ª´ng b∆∞·ªõc. H√£y chia nh·ªè th√†nh c√°c b∆∞·ªõc c·ª• th·ªÉ.';
                    break;
            }
        }

        // Add intent-specific context
        if (intentAnalysis.suggestedFlow) {
            prompt += `\n\n**G·ª£i √Ω:** C√¢u h·ªèi n√†y c√≥ th·ªÉ d·∫´n ƒë·∫øn t∆∞ v·∫•n ${intentAnalysis.suggestedFlow}. H√£y chu·∫©n b·ªã cho cu·ªôc h·ªôi tho·∫°i s√¢u h∆°n.`;
        }

        return prompt;
    }

    /**
     * üéØ Generate flow suggestion
     */
    generateFlowSuggestion(flowType) {
        const suggestions = {
            financial_planning: `
üí° **G·ª£i √Ω:** T√¥i c√≥ th·ªÉ gi√∫p b·∫°n l·∫≠p k·∫ø ho·∫°ch t√†i ch√≠nh chi ti·∫øt qua 4 b∆∞·ªõc:
1Ô∏è‚É£ ƒê√°nh gi√° thu nh·∫≠p
2Ô∏è‚É£ Ph√¢n t√≠ch chi ti√™u  
3Ô∏è‚É£ Thi·∫øt l·∫≠p m·ª•c ti√™u
4Ô∏è‚É£ ƒê·ªÅ xu·∫•t chi·∫øn l∆∞·ª£c

B·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu kh√¥ng? Ch·ªâ c·∫ßn n√≥i "B·∫Øt ƒë·∫ßu l·∫≠p k·∫ø ho·∫°ch t√†i ch√≠nh"`,

            investment_consultation: `
üí° **G·ª£i √Ω:** T√¥i c√≥ th·ªÉ t∆∞ v·∫•n ƒë·∫ßu t∆∞ c√° nh√¢n h√≥a qua 4 b∆∞·ªõc:
1Ô∏è‚É£ ƒê√°nh gi√° kh·∫£ nƒÉng ch·∫•p nh·∫≠n r·ªßi ro
2Ô∏è‚É£ X√°c ƒë·ªãnh v·ªën ƒë·∫ßu t∆∞
3Ô∏è‚É£ Ch·ªçn lo·∫°i h√¨nh ƒë·∫ßu t∆∞
4Ô∏è‚É£ ƒê·ªÅ xu·∫•t danh m·ª•c

B·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu kh√¥ng? Ch·ªâ c·∫ßn n√≥i "T∆∞ v·∫•n ƒë·∫ßu t∆∞ cho t√¥i"`,

            debt_management: `
üí° **G·ª£i √Ω:** T√¥i c√≥ th·ªÉ gi√∫p b·∫°n qu·∫£n l√Ω n·ª£ hi·ªáu qu·∫£ qua 4 b∆∞·ªõc:
1Ô∏è‚É£ ƒê√°nh gi√° t·ªïng n·ª£
2Ô∏è‚É£ X√°c ƒë·ªãnh thu nh·∫≠p
3Ô∏è‚É£ T√≠nh kh·∫£ nƒÉng tr·∫£ n·ª£
4Ô∏è‚É£ L·∫≠p k·∫ø ho·∫°ch tr·∫£ n·ª£

B·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu kh√¥ng? Ch·ªâ c·∫ßn n√≥i "Gi√∫p t√¥i qu·∫£n l√Ω n·ª£"`
        };

        return suggestions[flowType] || '';
    }

    /**
     * üèÜ Generate flow recommendation
     */
    async generateFlowRecommendation(userId, flowType, collectedData) {
        const recommendationPrompt = `
D·ª±a tr√™n th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ cung c·∫•p trong cu·ªôc h·ªôi tho·∫°i ${flowType}, h√£y ƒë∆∞a ra k·∫ø ho·∫°ch c·ª• th·ªÉ:

**D·ªØ li·ªáu ƒë√£ thu th·∫≠p:**
${Object.entries(collectedData).map(([key, value]) => `- ${key}: ${value}`).join('\n')}

**Y√™u c·∫ßu:**
- ƒê∆∞a ra k·∫ø ho·∫°ch chi ti·∫øt, t·ª´ng b∆∞·ªõc c·ª• th·ªÉ
- S·ª≠ d·ª•ng s·ªë li·ªáu th·ª±c t·∫ø ƒë·ªÉ t√≠nh to√°n
- ƒê·ªÅ xu·∫•t timeline th·ª±c hi·ªán
- C·∫£nh b√°o r·ªßi ro n·∫øu c√≥
- Khuy·∫øn ngh·ªã theo d√µi v√† ƒëi·ªÅu ch·ªânh

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, c√≥ c·∫•u tr√∫c r√µ r√†ng v·ªõi emoji.`;

        try {
            const recommendation = await this.agent.callGeminiAI(recommendationPrompt, {
                temperature: 0.6,
                maxOutputTokens: 1024
            });

            return `üéØ **K·∫ø ho·∫°ch ${flowType} c·ªßa b·∫°n:**\n\n${recommendation}`;

        } catch (error) {
            logger.error('Error generating flow recommendation:', error);
            return 'ƒê√£ ho√†n th√†nh thu th·∫≠p th√¥ng tin. T√¥i s·∫Ω ph√¢n t√≠ch v√† ƒë∆∞a ra k·∫ø ho·∫°ch c·ª• th·ªÉ cho b·∫°n.';
        }
    }

    /**
     * üÜò Fallback response
     */
    getFallbackResponse(message, financialData) {
        const summary = financialData.summary || {};
        const balance = (summary.totalIncomes || 0) - (summary.totalExpenses || 0);

        if (balance > 0) {
            return `D·ª±a tr√™n t√¨nh h√¨nh t√†i ch√≠nh c·ªßa b·∫°n (s·ªë d∆∞: ${balance.toLocaleString('vi-VN')} VND), t√¥i th·∫•y b·∫°n ƒëang qu·∫£n l√Ω t·ªët. V·ªÅ c√¢u h·ªèi "${message}", b·∫°n c√≥ th·ªÉ c·ª• th·ªÉ h∆°n ƒë·ªÉ t√¥i t∆∞ v·∫•n ch√≠nh x√°c h∆°n kh√¥ng?`;
        } else {
            return `T√¥i th·∫•y b·∫°n ƒëang c√≥ th√¢m h·ª•t ${Math.abs(balance).toLocaleString('vi-VN')} VND. V·ªÅ c√¢u h·ªèi "${message}", t√¥i c√≥ th·ªÉ gi√∫p b·∫°n c·∫£i thi·ªán t√¨nh h√¨nh t√†i ch√≠nh. B·∫°n mu·ªën t√¥i t∆∞ v·∫•n g√¨ c·ª• th·ªÉ?`;
        }
    }

    /**
     * üöÄ Start conversation flow manually
     */
    async startFlow(userId, flowType) {
        const flowResult = this.conversationManager.startConversationFlow(userId, flowType);
        
        if (!flowResult) {
            return {
                response: 'Lo·∫°i t∆∞ v·∫•n n√†y ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£. Vui l√≤ng th·ª≠ l·∫°i.',
                followUpQuestions: []
            };
        }

        return {
            response: `üöÄ **B·∫Øt ƒë·∫ßu ${flowType}**\n\nüìã **B∆∞·ªõc 1/${flowResult.totalSteps}:** ${flowResult.prompt}`,
            followUpQuestions: [],
            conversationContext: {
                flowStarted: true,
                flowType: flowResult.flowType,
                currentStep: flowResult.currentStep
            }
        };
    }

    /**
     * üìä Get conversation statistics
     */
    getConversationStats(userId) {
        return this.conversationManager.getConversationStats(userId);
    }

    /**
     * üóëÔ∏è Clear conversation
     */
    clearConversation(userId) {
        this.conversationManager.clearConversationContext(userId);
        return 'ƒê√£ x√≥a l·ªãch s·ª≠ h·ªôi tho·∫°i. Ch√∫ng ta c√≥ th·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi!';
    }
}

export default EnhancedConversationHandler;
